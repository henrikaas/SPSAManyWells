"""
Copyright (C) 2024 Solution Seeker AS - All Rights Reserved
You may use, distribute and modify this code under the
terms of the CC BY-NC 4.0 International Public License.

Created 05 April 2024
Bjarne Grimstad, bjarne.grimstad@solutionseeker.no

Implementation of slip models
"""


from dataclasses import dataclass

import casadi as ca
from manywells.ca_functions import ca_softmax
from manywells.constants import STD_GRAVITY
from manywells.pvt import dead_oil_surface_tension


def classify_flow_regime(v_g, v_l, alpha, rho_g, rho_l, T):
    """
    Classify flow regime (annular, slug/churn, or bubbly) based on the following conditions:

    If C1 and C2:
        then annular flow
    else if C3 and C4:
        then slug/churn flow
    else:
        bubbly flow

    where the conditions are
        C1: v_gs > 3.1 * (g * sigma * (rho_l - rho_g) / rho_g ** 2) ** (1/4)
        C2: alpha >= 0.7
        C3: v_gs > 1.08 * v_ls
        C4: alpha >= 0.25

    This is a simplified version of the flow regime hierarchy in "Simplified two-phase flow modeling in wellbores" by
    Hasan, Kabir & Sayarpur (2010). One simplification is that slug and churn flow has been combined into one class.
    Condition C1 and C3 are Eq. 19 and Eq. 18 in the paper, respectively.

    Above, v_gs and v_ls are the superficial gas and liquid velocities, computed as:
        v_gs = alpha * v_g and v_ls = (1 - alpha) * v_l.

    The classifier is built by first computing a feature vector from the above conditions:
        f1 = tanh(v_gs - 3.1 * (g * sigma * (rho_l - rho_g) / rho_g ** 2) ** (1/4))
        f2 = tanh(alpha - 0.7)
        f3 = tanh(v_gs - 1.08 * v_ls)
        f4 = tanh(alpha - 0.25)
        f = [f1, f2, f3, f4]

    An affine mapping of the features is then applied to give:
        y = [y_annular, y_slug, y_bubbly] = A f + b.

    The output is normalized using a softmax to give
        p = [p_annular, p_slug, p_bubbly] = softmax(y)
    which is a vector representing the probability of each flow regime, e.g. (0.9, 0.08, 0.02),
    where 0.9, 0.08, and 0.02 is the probability of annular, slug/churn, and bubbly flow, respectively.

    The parameters A and b are found by solving a classification problem on a dataset generated by random sampling the
    variables used to compute the features, and then using the exact conditions of the flow regime hierarchy to set the
    correct class. The fit was done by the logistic regression method from sklearn.linear_model
        LogisticRegression(multi_class='multinomial', penalty='l2', C=0.01, solver='lbfgs', fit_intercept=True)

    With L2-penalty C=0.01:
    A = np.array(
    [[ 3.17715258,  6.81938489,  0.30182974,  3.58362465],
       [-1.47973427, -4.34033317,  2.58200006,  3.49656911],
       [-1.6974183 , -2.47905172, -2.8838298 , -7.08019376]]
    )
    b = np.array([-3.92904391 -1.46509477  5.39413869])

    :param v_g: Gas velocity (m/s)
    :param v_l: Liquid velocity (m/s)
    :param alpha: Void fraction
    :param rho_g: Gas density (kg/m³)
    :param rho_l: Liquid density (kg/m³)
    :param T: Temperature (K)
    :return: Vector of probabilities of each flow regime, [p_annular, p_slug, p_bubbly]
    """
    v_gs = alpha * v_g  # Superficial gas velocity (m/s)
    v_ls = (1 - alpha) * v_l  # Superficial liquid velocity (m/s)

    # Compute surface tension and velocity condition for annular flow
    sigma = dead_oil_surface_tension(rho_l, T)
    annular_boundary = 3.1 * (STD_GRAVITY * sigma * (rho_l - rho_g) / rho_g ** 2) ** (1 / 4)

    # Conditions in flow regime hierarchy
    c_1 = ca.tanh(v_gs - annular_boundary)  # Eq. A-19 in Hasan, Kabir & Sayarpur (2010)
    c_2 = ca.tanh((alpha - 0.7) * 2)  # Multiplied by 2 to increase sensitivity
    c_3 = ca.tanh(v_gs - 1.08 * v_ls)  # Eq. A-18 in Hasan, Kabir & Sayarpur (2010)
    c_4 = ca.tanh((alpha - 0.25) * 2)  # Multiplied by 2 to increase sensitivity

    # Output layer
    y_1 = 3.17715258 * c_1 + 6.81938489 * c_2 + 0.30182974 * c_3 + 3.58362465 * c_4 - 3.92904391  # Annular flow
    y_2 = -1.47973427 * c_1 - 4.34033317 * c_2 + 2.58200006 * c_3 + 3.49656911 * c_4 - 1.46509477  # Slug/churn flow
    y_3 = -1.6974183 * c_1 - 2.47905172 * c_2 - 2.8838298 * c_3 - 7.08019376 * c_4 + 5.39413869  # Bubbly flow

    y = ca.vertcat(*[y_1, y_2, y_3])

    p = ca_softmax(y)

    return p


@dataclass
class SlipModel:
    """
    Slip model:
        v_g = C_0 * v_m + v_inf
    where the parameters C_0 and v_inf are determined based on the flow regime (bubbly, slug / churn, or annular flow).

    Inspired by the slip model in the paper "Simplified two-phase flow modeling in wellbores"
    by Hasan, Kabir & Sayarpur (2010).
    """

    # Profile parameter for different flow regimes
    C_0_annular = 1.0
    C_0_slug = 1.175
    C_0_bubbly = 1.2

    # Drift velocity
    v_inf_annular = 0.0

    @staticmethod
    def harmathy_rise_velocity(rho_g, rho_l, T):
        """
        Harmathy correlation for small bubble rise velocity

        :param rho_g: Gas density (kg/m³)
        :param rho_l: Liquid density (kg/m³)
        :param T: Temperature in (K)
        :return: Bubble rise velocity (m/s)
        """
        s = dead_oil_surface_tension(rho=rho_l, T=T)  # Liquid surface tension (J/m²)
        return 1.53 * ca.constpow(STD_GRAVITY * s * (rho_l - rho_g) / (rho_l ** 2), 1 / 4)

    @staticmethod
    def taylor_rise_velocity(rho_g, rho_l, D):
        """
        Correlation for Taylor-bubble rise velocity
        :param rho_g: Gas density (kg/m³)
        :param rho_l: Liquid density (kg/m³)
        :param D: Inner diameter of pipe (m)
        :return: Bubble rise velocity (m/s)
        """
        return 0.35 * ca.sqrt(STD_GRAVITY * D * (1 - rho_g / rho_l))

    def identify_parameters(self, v_g, v_l, alpha, rho_g, rho_l, T, D):
        """
        Compute slip model parameters (C_0, v_inf) based on void fraction, alpha

        :param alpha: Void fraction
        :return: C_0, v_inf
        """

        probs = classify_flow_regime(v_g, v_l, alpha, rho_g, rho_l, T)
        p_annular = probs[0]
        p_slug = probs[1]
        p_bubbly = probs[2]

        # Set profile parameter
        C_0 = p_annular * self.C_0_annular + p_slug * self.C_0_slug + p_bubbly * self.C_0_bubbly

        # Set drift velocity
        v_inf_annular = self.v_inf_annular
        v_inf_slug = self.taylor_rise_velocity(rho_g, rho_l, D)
        v_inf_bubbly = self.harmathy_rise_velocity(rho_g, rho_l, T)

        v_inf = p_annular * v_inf_annular + p_slug * v_inf_slug + p_bubbly * v_inf_bubbly

        return C_0, v_inf

    def slip_equation(self, v_g, v_l, alpha, rho_g, rho_l, T, D):
        """
        Compute slip law: v_g = C_0 * v_m + v_inf, where v_m is the mixture velocity
        """
        C_0, v_inf = self.identify_parameters(v_g, v_l, alpha, rho_g, rho_l, T, D)
        v_m = alpha * v_g + (1 - alpha) * v_l  # Mixture velocity
        eq = v_g - (C_0 * v_m + v_inf)
        return eq

    def flow_regime(self, v_g, v_l, alpha, rho_g, rho_l, T) -> str:
        """
        Return textual description of classified (most probable) flow regime
        """
        probs = classify_flow_regime(v_g, v_l, alpha, rho_g, rho_l, T)
        p_annular, p_slug, p_bubbly = probs.full().flatten().tolist()
        if p_annular > p_slug and p_annular > p_bubbly:
            return 'annular'
        elif p_slug > p_annular and p_slug > p_bubbly:
            return 'slug-churn'
        else:
            return 'bubbly'



if __name__ == '__main__':

    x = ca.SX.sym(f'x', 3)
    f = ca.exp(x)
    f = ca.tanh(x)
    f = ca_softmax(x)
    fun = ca.Function('fun', [x], [f])
    y = fun([1, 2, 3]).full()
    print(y)

    # Test classification
    alpha = 0.5
    v_g = 20
    v_l = 5
    rho_g = 1
    rho_l = 900
    T = 273.15 + 20
    probs = classify_flow_regime(v_g, v_l, alpha, rho_g, rho_l, T)

    # annular boundary = 12.821059412975487
    print(probs.full())
    print(ca.sum1(probs).full())

    print(probs.full().flatten()[0])  # Annular flow
    print(probs.full().flatten()[1])  # Slug/churn flow
    print(probs.full().flatten()[2])  # Bubbly flow

    model = SlipModel()
    C_0, v_inf = model.identify_parameters(v_g, v_l, alpha, rho_g, rho_l, T, D=0.1)
    print(C_0, v_inf)





